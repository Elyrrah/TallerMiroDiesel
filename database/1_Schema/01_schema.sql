-- =============================================================================
-- 01 - SCHEMAS (ESTRUCTURA)
-- INCLUYE: CONFIGURACIÓN, TABLAS, IDENTITY, DEFAULTS, CONSTRAINTS (FK / CHECK),
--          ÍNDICES ESTRUCTURALES Y TRIGGERS DE INTEGRIDAD
-- =============================================================================

-- =============================================================================
-- CONFIGURACIÓN INICIAL
-- =============================================================================
SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

SET default_tablespace = '';
SET default_table_access_method = heap;

-- =============================================================================
-- 01 - SCHEMA (GEOGRAFÍA)
-- PAÍS -> DEPARTAMENTO -> DISTRITO -> LOCALIDAD
-- =============================================================================

-- PAISES: LISTA DE PAÍSES
CREATE TABLE IF NOT EXISTS public.paises (
    id_pais bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre character varying(100) NOT NULL UNIQUE,
    iso2 char(2) UNIQUE,
    iso3 char(3) UNIQUE,
    activo boolean DEFAULT true NOT NULL
);

-- DEPARTAMENTOS: AGRUPACIÓN TERRITORIAL DENTRO DE UN PAÍS
CREATE TABLE IF NOT EXISTS public.departamentos (
    id_departamento bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_pais bigint NOT NULL,
    nombre character varying(120) NOT NULL UNIQUE,
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT departamentos_id_pais_fkey
        FOREIGN KEY (id_pais) REFERENCES public.paises(id_pais)
);

-- DISTRITOS: DIVISIÓN TERRITORIAL DENTRO DE UN DEPARTAMENTO
CREATE TABLE IF NOT EXISTS public.distritos (
    id_distrito bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_departamento bigint NOT NULL,
    nombre character varying(120) NOT NULL,
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT distritos_id_departamento_fkey
        FOREIGN KEY (id_departamento) REFERENCES public.departamentos(id_departamento),
    CONSTRAINT distritos_unique_departamento_nombre
        UNIQUE (id_departamento, nombre)
);

-- LOCALIDADES: BARRIOS/ZONA/LOCALIDAD DENTRO DE UN DISTRITO
CREATE TABLE IF NOT EXISTS public.localidades (
    id_localidad bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_distrito bigint NOT NULL,
    nombre character varying(120) NOT NULL,
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT localidades_id_distrito_fkey
        FOREIGN KEY (id_distrito) REFERENCES public.distritos(id_distrito),
    CONSTRAINT localidades_unique_distrito_nombre
        UNIQUE (id_distrito, nombre)
);

-- =============================================================================
-- CLIENTES Y DOCUMENTOS
-- =============================================================================

-- TIPOS DE DOCUMENTO: DNI, RUC, PASAPORTE, ETC.
CREATE TABLE IF NOT EXISTS public.tipos_documento (
    id_tipo_documento bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    codigo character varying(20) NOT NULL UNIQUE,
    nombre character varying(120) NOT NULL,
    aplica_a public.tipo_documento_aplica_enum NOT NULL,
    activo boolean DEFAULT true NOT NULL
);

-- CLIENTES: TABLA BASE DE CLIENTES
CREATE TABLE IF NOT EXISTS public.clientes (
    id_cliente bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    telefono character varying(30),
    email character varying(100),
    direccion character varying(255),
    id_distrito bigint,
    id_localidad bigint,
    -- referencia: vino por recomendación de otro cliente
    id_cliente_referidor bigint,
    fuente_referencia public.fuente_referencia_cliente_enum,
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT clientes_id_distrito_fkey
        FOREIGN KEY (id_distrito) REFERENCES public.distritos(id_distrito),
    CONSTRAINT clientes_id_localidad_fkey
        FOREIGN KEY (id_localidad) REFERENCES public.localidades(id_localidad),
    CONSTRAINT clientes_id_cliente_referidor_fkey
        FOREIGN KEY (id_cliente_referidor)
        REFERENCES public.clientes (id_cliente)
        ON UPDATE CASCADE
        ON DELETE SET NULL,
    -- evita que un cliente se refiera a sí mismo
    CONSTRAINT clientes_referidor_no_self
        CHECK (id_cliente_referidor IS NULL OR id_cliente_referidor <> id_cliente),
    -- si hay fuente de referencia, debe existir cliente referidor (y viceversa)
    CONSTRAINT clientes_ref_fuente_y_referidor
        CHECK (
            (fuente_referencia IS NULL AND id_cliente_referidor IS NULL)
            OR
            (fuente_referencia IS NOT NULL AND id_cliente_referidor IS NOT NULL)
        )
);

-- =============================================================================
-- 03 - POST
-- ÍNDICES · CONSTRAINTS · FUNCIONES · TRIGGERS
--
-- Este script define toda la lógica posterior a la creación de tablas:
--  • Índices para mejorar el rendimiento de consultas frecuentes
--  • Constraints de negocio que no pertenecen al esquema base
--  • Funciones que encapsulan reglas y automatismos
--  • Triggers que activan dichas funciones de forma transparente
--
-- El script es completamente idempotente y seguro de ejecutar múltiples veces.
-- =============================================================================

BEGIN;

-- =============================================================================
-- ÍNDICES
-- =============================================================================

-- Optimiza búsquedas por nombre y apellido en clientes persona
CREATE INDEX IF NOT EXISTS idx_clientes_persona_busqueda
ON public.clientes_persona (nombre, apellido);

-- Optimiza búsquedas por apodo o alias del cliente persona
CREATE INDEX IF NOT EXISTS idx_clientes_persona_apodo
ON public.clientes_persona (apodo);

-- Optimiza búsquedas por nombre de fantasía en clientes empresa
CREATE INDEX IF NOT EXISTS idx_clientes_empresa_nombre_fantasia
ON public.clientes_empresa (nombre_fantasia);

-- Optimiza búsquedas por razón social en clientes empresa
CREATE INDEX IF NOT EXISTS idx_clientes_empresa_razon_social
ON public.clientes_empresa (razon_social);

-- Acelera el filtrado y listado de órdenes de trabajo por estado
CREATE INDEX IF NOT EXISTS idx_ordenes_trabajo_estado
ON public.ordenes_trabajo (estado);

-- Optimiza consultas que buscan OT de un cliente específico y por estado
CREATE INDEX IF NOT EXISTS idx_ordenes_trabajo_cliente_estado
ON public.ordenes_trabajo (id_cliente, estado);

-- Mejora el rendimiento de búsquedas de OT por vehículo
CREATE INDEX IF NOT EXISTS idx_ordenes_trabajo_vehiculo
ON public.ordenes_trabajo (id_vehiculo);

-- Optimiza consultas de pagos filtrando por plan de pago y orden de trabajo
CREATE INDEX IF NOT EXISTS idx_pagos_plan_ot
ON public.pagos (id_plan_pago, id_orden_trabajo);

-- CLIENTES / VEHICULOS / COMPONENTES: acelera listados y joins por cliente
CREATE INDEX IF NOT EXISTS idx_vehiculos_id_cliente
ON public.vehiculos (id_cliente);

CREATE INDEX IF NOT EXISTS idx_componentes_id_cliente
ON public.componentes (id_cliente);

-- ORDENES y DETALLES: acelera listados, joins y recalculo de totales
CREATE INDEX IF NOT EXISTS idx_ordenes_trabajo_id_usuario
ON public.ordenes_trabajo (id_usuario);

-- Acelera joins y consultas de detalles por orden de trabajo
CREATE INDEX IF NOT EXISTS idx_ot_detalles_id_ot
ON public.orden_trabajo_detalles (id_orden_trabajo);

-- Optimiza joins y consultas de detalles por servicio aplicado
CREATE INDEX IF NOT EXISTS idx_ot_detalles_id_servicio
ON public.orden_trabajo_detalles (id_servicio);

-- PLANES y EVENTOS: acelera consultas y joins desde OT y plan
CREATE INDEX IF NOT EXISTS idx_planes_pago_id_ot
ON public.planes_pago (id_orden_trabajo);

CREATE INDEX IF NOT EXISTS idx_planes_pago_eventos_id_plan
ON public.planes_pago_eventos (id_plan_pago);

-- PAGOS: índice por usuario para listados/reportes
CREATE INDEX IF NOT EXISTS idx_pagos_id_usuario
ON public.pagos (id_usuario);

-- Evita duplicar documentos activos por tipo + número dentro del mismo cliente
CREATE UNIQUE INDEX IF NOT EXISTS ux_cliente_documentos_cliente_tipo_numero_activo
ON public.cliente_documentos (id_cliente, id_tipo_documento, numero)
WHERE activo = true;

-- Optimiza joins y filtros por cliente en documentos,
-- especialmente en consultas de perfil del cliente y validaciones de documentos
CREATE INDEX IF NOT EXISTS idx_cliente_documentos_id_cliente
ON public.cliente_documentos (id_cliente);

-- Acelera búsquedas y joins por tipo de documento,
-- útil para listados, validaciones y controles administrativos
CREATE INDEX IF NOT EXISTS idx_cliente_documentos_id_tipo_documento
ON public.cliente_documentos (id_tipo_documento);

-- USUARIOS: acelera listados y joins por rol asignado
CREATE INDEX IF NOT EXISTS idx_usuarios_id_rol
ON public.usuarios (id_rol);

-- =============================================================================
-- LIMPIEZA DE DUPLICADOS (SE DEJAN LOS DEL SCHEMA)
-- =============================================================================

-- Un solo documento principal activo por cliente
-- (SE ELIMINA DEL POST: YA EXISTE EN EL SCHEMA COMO ÍNDICE ÚNICO PARCIAL)

-- Autocompleta distrito cuando se selecciona localidad en el cliente
-- y valida consistencia entre distrito y localidad cuando ambos existen
-- (SE ELIMINA DEL POST: YA EXISTE EN EL SCHEMA COMO FUNCIÓN/TRIGGER)

DROP TRIGGER IF EXISTS trg_clientes_set_distrito_por_localidad ON public.clientes;
DROP FUNCTION IF EXISTS public.fn_clientes_set_distrito_por_localidad();

-- =============================================================================
-- CHECK / UNIQUE CONSTRAINTS (IDEMPOTENTES)
-- =============================================================================

-- Garantiza que una orden de trabajo esté asociada exclusivamente
-- a un vehículo o a un componente, según el tipo de ingreso definido
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM pg_constraint
        WHERE conname = 'check_ot_sujeto_por_tipo'
          AND conrelid = 'public.ordenes_trabajo'::regclass
    ) THEN
        ALTER TABLE public.ordenes_trabajo
        ADD CONSTRAINT check_ot_sujeto_por_tipo
        CHECK (
            (tipo_ingreso = 'VEHICULO'   AND id_vehiculo   IS NOT NULL AND id_componente IS NULL) OR
            (tipo_ingreso = 'COMPONENTE' AND id_componente IS NOT NULL AND id_vehiculo   IS NULL)
        );
    END IF;
END $$;

-- Impide registrar servicios con precios base negativos
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM pg_constraint
        WHERE conname = 'check_precio_base_no_negativo'
          AND conrelid = 'public.servicios'::regclass
    ) THEN
        ALTER TABLE public.servicios
        ADD CONSTRAINT check_precio_base_no_negativo
        CHECK (precio_base >= 0);
    END IF;
END $$;

-- Evita precios unitarios negativos en los detalles de orden
-- (SE ELIMINA DEL POST: YA SE AGREGA EN EL SCHEMA COMO CONSTRAINT)

-- Asegura que la cantidad de trabajos o servicios sea siempre mayor a cero
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM pg_constraint
        WHERE conname = 'check_cantidad_minima'
          AND conrelid = 'public.orden_trabajo_detalles'::regclass
    ) THEN
        ALTER TABLE public.orden_trabajo_detalles
        ADD CONSTRAINT check_cantidad_minima
        CHECK (cantidad > 0);
    END IF;
END $$;

-- Impide valores negativos en la garantía expresada en meses
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM pg_constraint
        WHERE conname = 'check_garantia_meses_no_negativo'
          AND conrelid = 'public.orden_trabajo_detalles'::regclass
    ) THEN
        ALTER TABLE public.orden_trabajo_detalles
        ADD CONSTRAINT check_garantia_meses_no_negativo
        CHECK (garantia_meses IS NULL OR garantia_meses >= 0);
    END IF;
END $$;

-- Impide valores negativos en la garantía expresada en días
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM pg_constraint
        WHERE conname = 'check_garantia_dias_no_negativo'
          AND conrelid = 'public.orden_trabajo_detalles'::regclass
    ) THEN
        ALTER TABLE public.orden_trabajo_detalles
        ADD CONSTRAINT check_garantia_dias_no_negativo
        CHECK (garantia_dias IS NULL OR garantia_dias >= 0);
    END IF;
END $$;

-- Evita duplicar componentes para un mismo cliente, tipo, marca y modelo
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM pg_constraint
        WHERE conname = 'componentes_unique_cliente_tipo_marca_modelo'
          AND conrelid = 'public.componentes'::regclass
    ) THEN
        ALTER TABLE public.componentes
        ADD CONSTRAINT componentes_unique_cliente_tipo_marca_modelo
        UNIQUE (id_cliente, tipo_componente, id_marca, id_modelo);
    END IF;
END $$;

-- Asegura que la cantidad declarada de componentes sea siempre positiva
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM pg_constraint
        WHERE conname = 'check_componentes_cantidad_positiva'
          AND conrelid = 'public.componentes'::regclass
    ) THEN
        ALTER TABLE public.componentes
        ADD CONSTRAINT check_componentes_cantidad_positiva
        CHECK (cantidad > 0);
    END IF;
END $$;

-- Impide registrar pagos con monto cero o negativo
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM pg_constraint
        WHERE conname = 'check_pagos_monto_positivo'
          AND conrelid = 'public.pagos'::regclass
    ) THEN
        ALTER TABLE public.pagos
        ADD CONSTRAINT check_pagos_monto_positivo
        CHECK (monto > 0);
    END IF;
END $$;

-- Asegura coherencia mínima del plan de pago según el tipo:
--   • CONTADO debe tener exactamente 1 cuota
--   • CUOTAS debe tener 1 o más cuotas
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM pg_constraint
        WHERE conname = 'check_planes_pago_tipo_vs_cuotas'
          AND conrelid = 'public.planes_pago'::regclass
    ) THEN
        ALTER TABLE public.planes_pago
        ADD CONSTRAINT check_planes_pago_tipo_vs_cuotas
        CHECK (
            (tipo_plan = 'CONTADO' AND cantidad_cuotas = 1)
         OR (tipo_plan = 'CUOTAS'  AND cantidad_cuotas >= 1)
        );
    END IF;
END $$;

-- Impide registrar planes de pago con monto de cuota negativo
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1
        FROM pg_constraint
        WHERE conname = 'check_planes_pago_monto_cuota_no_negativo'
          AND conrelid = 'public.planes_pago'::regclass
    ) THEN
        ALTER TABLE public.planes_pago
        ADD CONSTRAINT check_planes_pago_monto_cuota_no_negativo
        CHECK (monto_cuota >= 0);
    END IF;
END $$;

-- =============================================================================
-- FUNCIONES
-- =============================================================================

-- 1) Inicializa órdenes de trabajo asignando estado y número correlativo mensual
CREATE OR REPLACE FUNCTION public.fn_ordenes_trabajo_inicio()
RETURNS trigger AS $$
DECLARE
    v_anio text;
    v_mes text;
    v_prefix text;
    v_ultimo integer;
BEGIN
    -- Usar valor ENUM RECIBIDO por defecto
    IF NEW.estado IS NULL THEN
        NEW.estado := 'RECIBIDO';
    END IF;

    IF NEW.numero_orden IS NULL OR NEW.numero_orden = '' THEN
        v_anio := to_char(now(), 'YYYY');
        v_mes  := to_char(now(), 'MM');
        v_prefix := 'OT-' || v_anio || '-' || v_mes || '-';

        PERFORM pg_advisory_xact_lock(hashtext(v_prefix));

        SELECT COALESCE(
            MAX(substring(numero_orden from '([0-9]{3})$')::int),
            0
        )
        INTO v_ultimo
        FROM public.ordenes_trabajo
        WHERE numero_orden LIKE v_prefix || '%';

        NEW.numero_orden := v_prefix || lpad((v_ultimo + 1)::text, 3, '0');
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 2) Completa automáticamente el precio unitario del detalle
-- Nota (decisión actual):
--   Si el precio_unitario viene NULL o 0, se autocompleta con el precio_base.
--   Esto fuerza que "0" no sea considerado un valor manual válido.
CREATE OR REPLACE FUNCTION public.fn_ot_detalle_precio_auto()
RETURNS trigger AS $$
BEGIN
    IF NEW.precio_unitario IS NULL OR NEW.precio_unitario = 0 THEN
        SELECT s.precio_base
        INTO NEW.precio_unitario
        FROM public.servicios s
        WHERE s.id_servicio = NEW.id_servicio;
    END IF;

    NEW.precio_unitario := COALESCE(NEW.precio_unitario, 0);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 3) Recalcula el total estimado de la orden
CREATE OR REPLACE FUNCTION public.fn_ot_actualizar_total_cabecera()
RETURNS trigger AS $$
DECLARE
    v_id_ot bigint;
BEGIN
    v_id_ot := COALESCE(NEW.id_orden_trabajo, OLD.id_orden_trabajo);

    UPDATE public.ordenes_trabajo
    SET total_estimado = (
        SELECT COALESCE(SUM(subtotal), 0)
        FROM public.orden_trabajo_detalles
        WHERE id_orden_trabajo = v_id_ot
    )
    WHERE id_orden_trabajo = v_id_ot;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- 4) Controla la fecha de finalización según el estado de la orden (usando ENUM FINALIZADO)
CREATE OR REPLACE FUNCTION public.fn_ordenes_trabajo_fechas_estado()
RETURNS trigger AS $$
BEGIN
    IF NEW.estado = 'FINALIZADO' AND (OLD.estado IS NULL OR OLD.estado <> 'FINALIZADO') THEN
        NEW.fecha_fin := now();
    END IF;

    IF NEW.estado <> 'FINALIZADO' AND OLD.estado = 'FINALIZADO' THEN
        NEW.fecha_fin := NULL;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 5) Valida coherencia entre marca y modelo del vehículo
CREATE OR REPLACE FUNCTION public.fn_vehiculos_validar_modelo_marca()
RETURNS trigger AS $$
DECLARE
    v_marca_modelo bigint;
BEGIN
    IF NEW.id_modelo IS NOT NULL THEN
        SELECT id_marca
        INTO v_marca_modelo
        FROM public.modelos
        WHERE id_modelo = NEW.id_modelo;

        IF v_marca_modelo IS NULL THEN
            RAISE EXCEPTION 'Modelo inválido: %', NEW.id_modelo;
        END IF;

        IF v_marca_modelo <> NEW.id_marca THEN
            RAISE EXCEPTION
                'El modelo % no pertenece a la marca %', NEW.id_modelo, NEW.id_marca;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 6) Valida coherencia entre marca y modelo del componente
CREATE OR REPLACE FUNCTION public.fn_componentes_validar_modelo_marca()
RETURNS trigger AS $$
DECLARE
    v_marca_modelo bigint;
BEGIN
    SELECT id_marca
    INTO v_marca_modelo
    FROM public.modelos
    WHERE id_modelo = NEW.id_modelo;

    IF v_marca_modelo IS NULL THEN
        RAISE EXCEPTION 'Modelo inválido: %', NEW.id_modelo;
    END IF;

    IF v_marca_modelo <> NEW.id_marca THEN
        RAISE EXCEPTION
            'El modelo % no pertenece a la marca %', NEW.id_modelo, NEW.id_marca;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 7) Impide que un cliente sea persona y empresa simultáneamente
CREATE OR REPLACE FUNCTION public.fn_clientes_evitar_doble_tipo()
RETURNS trigger AS $$
BEGIN
    IF TG_TABLE_NAME = 'clientes_persona' THEN
        IF EXISTS (SELECT 1 FROM public.clientes_empresa WHERE id_cliente = NEW.id_cliente) THEN
            RAISE EXCEPTION 'El cliente % ya está registrado como EMPRESA', NEW.id_cliente;
        END IF;
    END IF;

    IF TG_TABLE_NAME = 'clientes_empresa' THEN
        IF EXISTS (SELECT 1 FROM public.clientes_persona WHERE id_cliente = NEW.id_cliente) THEN
            RAISE EXCEPTION 'El cliente % ya está registrado como PERSONA', NEW.id_cliente;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 8) Calcula automáticamente las fechas de garantía al finalizar la orden
CREATE OR REPLACE FUNCTION public.fn_ot_detalles_calcular_garantia_al_terminar()
RETURNS trigger AS $$
DECLARE
    v_desde date;
BEGIN
    IF NEW.estado = 'FINALIZADO' AND (OLD.estado IS NULL OR OLD.estado <> 'FINALIZADO') THEN
        IF NEW.fecha_fin IS NULL THEN
            NEW.fecha_fin := now();
        END IF;

        v_desde := (NEW.fecha_fin)::date;

        UPDATE public.orden_trabajo_detalles
        SET garantia_desde = v_desde,
            garantia_hasta = (
                v_desde
                + COALESCE((garantia_meses || ' months')::interval, interval '0 months')
                + COALESCE((garantia_dias  || ' days')::interval,  interval '0 days')
            )::date
        WHERE id_orden_trabajo = NEW.id_orden_trabajo
          AND (
                (garantia_meses IS NOT NULL AND garantia_meses > 0)
             OR (garantia_dias  IS NOT NULL AND garantia_dias  > 0)
          );

        UPDATE public.orden_trabajo_detalles
        SET garantia_desde = NULL,
            garantia_hasta = NULL
        WHERE id_orden_trabajo = NEW.id_orden_trabajo
          AND NOT (
                (garantia_meses IS NOT NULL AND garantia_meses > 0)
             OR (garantia_dias  IS NOT NULL AND garantia_dias  > 0)
          );
    END IF;

    IF NEW.estado <> 'FINALIZADO' AND OLD.estado = 'FINALIZADO' THEN
        UPDATE public.orden_trabajo_detalles
        SET garantia_desde = NULL,
            garantia_hasta = NULL
        WHERE id_orden_trabajo = NEW.id_orden_trabajo;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 9) Impide borrar clientes que tengan OT abiertas
CREATE OR REPLACE FUNCTION public.fn_clientes_no_borrar_ot()
RETURNS trigger AS $$
BEGIN
    IF EXISTS (
        SELECT 1
        FROM public.ordenes_trabajo
        WHERE id_cliente = OLD.id_cliente
          AND estado <> 'FINALIZADO'
    ) THEN
        RAISE EXCEPTION 'No se puede borrar el cliente %, tiene órdenes de trabajo abiertas', OLD.id_cliente;
    END IF;

    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- TRIGGERS
-- =============================================================================

-- Asigna estado inicial y número correlativo al crear una orden de trabajo
DROP TRIGGER IF EXISTS trg_ordenes_trabajo_inicio ON public.ordenes_trabajo;
CREATE TRIGGER trg_ordenes_trabajo_inicio
BEFORE INSERT ON public.ordenes_trabajo
FOR EACH ROW EXECUTE FUNCTION public.fn_ordenes_trabajo_inicio();

-- Completa el precio unitario del detalle antes de guardar el registro
DROP TRIGGER IF EXISTS trg_ot_detalle_precio_auto ON public.orden_trabajo_detalles;
CREATE TRIGGER trg_ot_detalle_precio_auto
BEFORE INSERT OR UPDATE ON public.orden_trabajo_detalles
FOR EACH ROW EXECUTE FUNCTION public.fn_ot_detalle_precio_auto();

-- Recalcula el total estimado de la orden ante cualquier cambio en los detalles
DROP TRIGGER IF EXISTS trg_ot_detalle_actualizar_total ON public.orden_trabajo_detalles;
CREATE TRIGGER trg_ot_detalle_actualizar_total
AFTER INSERT OR UPDATE OR DELETE ON public.orden_trabajo_detalles
FOR EACH ROW EXECUTE FUNCTION public.fn_ot_actualizar_total_cabecera();

-- Actualiza o limpia la fecha de finalización según el estado de la orden
DROP TRIGGER IF EXISTS trg_ordenes_trabajo_fechas ON public.ordenes_trabajo;
DROP TRIGGER IF EXISTS trg_ot_10_fechas_estado ON public.ordenes_trabajo;

CREATE TRIGGER trg_ot_10_fechas_estado
BEFORE UPDATE OF estado ON public.ordenes_trabajo
FOR EACH ROW EXECUTE FUNCTION public.fn_ordenes_trabajo_fechas_estado();

-- Valida que el modelo seleccionado pertenezca a la marca del vehículo
DROP TRIGGER IF EXISTS trg_vehiculos_validar_modelo_marca ON public.vehiculos;
CREATE TRIGGER trg_vehiculos_validar_modelo_marca
BEFORE INSERT OR UPDATE OF id_marca, id_modelo ON public.vehiculos
FOR EACH ROW EXECUTE FUNCTION public.fn_vehiculos_validar_modelo_marca();

-- Valida que el modelo seleccionado pertenezca a la marca del componente
DROP TRIGGER IF EXISTS trg_componentes_validar_modelo_marca ON public.componentes;
CREATE TRIGGER trg_componentes_validar_modelo_marca
BEFORE INSERT OR UPDATE OF id_marca, id_modelo
ON public.componentes
FOR EACH ROW EXECUTE FUNCTION public.fn_componentes_validar_modelo_marca();

-- Evita registrar un cliente persona si ya existe como empresa
DROP TRIGGER IF EXISTS trg_clientes_persona_no_empresa ON public.clientes_persona;
CREATE TRIGGER trg_clientes_persona_no_empresa
BEFORE INSERT OR UPDATE OF id_cliente ON public.clientes_persona
FOR EACH ROW EXECUTE FUNCTION public.fn_clientes_evitar_doble_tipo();

-- Evita registrar un cliente empresa si ya existe como persona
DROP TRIGGER IF EXISTS trg_clientes_empresa_no_persona ON public.clientes_empresa;
CREATE TRIGGER trg_clientes_empresa_no_persona
BEFORE INSERT OR UPDATE OF id_cliente ON public.clientes_empresa
FOR EACH ROW EXECUTE FUNCTION public.fn_clientes_evitar_doble_tipo();

-- Calcula automáticamente la garantía de los trabajos al finalizar la orden
DROP TRIGGER IF EXISTS trg_ot_calcular_garantia ON public.ordenes_trabajo;
DROP TRIGGER IF EXISTS trg_ot_20_calcular_garantia ON public.ordenes_trabajo;

CREATE TRIGGER trg_ot_20_calcular_garantia
BEFORE UPDATE OF estado ON public.ordenes_trabajo
FOR EACH ROW EXECUTE FUNCTION public.fn_ot_detalles_calcular_garantia_al_terminar();

-- Trigger preventivo de borrado de cliente
DROP TRIGGER IF EXISTS trg_clientes_no_borrar_ot ON public.clientes;
CREATE TRIGGER trg_clientes_no_borrar_ot
BEFORE DELETE ON public.clientes
FOR EACH ROW EXECUTE FUNCTION public.fn_clientes_no_borrar_ot();

COMMIT;

-- =============================================================================
-- FIN DEL SCRIPT 03 - POST
-- =============================================================================


-- CLIENTES PERSONA: DATOS ESPECÍFICOS DE PERSONAS
CREATE TABLE IF NOT EXISTS public.clientes_persona (
    id_cliente bigint PRIMARY KEY,
    nombre character varying(120) NOT NULL,
    apellido character varying(120) NOT NULL,
    apodo character varying(30),
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT clientes_persona_id_cliente_fkey
        FOREIGN KEY (id_cliente) REFERENCES public.clientes(id_cliente)
);

-- CLIENTES EMPRESA: DATOS ESPECÍFICOS DE EMPRESAS
CREATE TABLE IF NOT EXISTS public.clientes_empresa (
    id_cliente bigint PRIMARY KEY,
    razon_social character varying(255) NOT NULL,
    nombre_fantasia character varying(50),
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT clientes_empresa_id_cliente_fkey
        FOREIGN KEY (id_cliente) REFERENCES public.clientes(id_cliente)
);

-- trigger clientes: impide que un cliente sea persona y empresa simultáneamente
CREATE OR REPLACE FUNCTION public.fn_clientes_evitar_doble_tipo()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
    IF TG_TABLE_NAME = 'clientes_persona' THEN
        IF EXISTS (SELECT 1 FROM public.clientes_empresa WHERE id_cliente = NEW.id_cliente) THEN
            RAISE EXCEPTION 'EL CLIENTE % YA ESTÁ REGISTRADO COMO EMPRESA', NEW.id_cliente;
        END IF;
    END IF;

    IF TG_TABLE_NAME = 'clientes_empresa' THEN
        IF EXISTS (SELECT 1 FROM public.clientes_persona WHERE id_cliente = NEW.id_cliente) THEN
            RAISE EXCEPTION 'EL CLIENTE % YA ESTÁ REGISTRADO COMO PERSONA', NEW.id_cliente;
        END IF;
    END IF;

    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_clientes_persona_no_empresa ON public.clientes_persona;
CREATE TRIGGER trg_clientes_persona_no_empresa
BEFORE INSERT OR UPDATE OF id_cliente ON public.clientes_persona
FOR EACH ROW
EXECUTE FUNCTION public.fn_clientes_evitar_doble_tipo();

DROP TRIGGER IF EXISTS trg_clientes_empresa_no_persona ON public.clientes_empresa;
CREATE TRIGGER trg_clientes_empresa_no_persona
BEFORE INSERT OR UPDATE OF id_cliente ON public.clientes_empresa
FOR EACH ROW
EXECUTE FUNCTION public.fn_clientes_evitar_doble_tipo();

-- CLIENTE_DOCUMENTOS: DOCUMENTOS DE CLIENTES (PUEDE TENER VARIOS, CON INDICADOR DE PRINCIPAL)
CREATE TABLE IF NOT EXISTS public.cliente_documentos (
    id_cliente_documento bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_cliente bigint NOT NULL,
    id_tipo_documento bigint NOT NULL,
    numero character varying(40) NOT NULL,
    principal boolean DEFAULT false NOT NULL,
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT cliente_documentos_id_cliente_fkey
        FOREIGN KEY (id_cliente) REFERENCES public.clientes(id_cliente),
    CONSTRAINT cliente_documentos_id_tipo_documento_fkey
        FOREIGN KEY (id_tipo_documento) REFERENCES public.tipos_documento(id_tipo_documento)
);

-- índice único parcial: evita más de un documento principal activo por cliente
CREATE UNIQUE INDEX IF NOT EXISTS uq_cliente_documentos_principal
ON public.cliente_documentos (id_cliente)
WHERE principal = true AND activo = true;

-- =============================================================================
-- MARCAS / MODELOS
-- =============================================================================

-- MARCAS: MARCAS DE VEHÍCULOS O COMPONENTES
CREATE TABLE IF NOT EXISTS public.marcas (
    id_marca bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre character varying(50) NOT NULL UNIQUE,
    activo boolean DEFAULT true NOT NULL
);

-- MODELOS: MODELOS ASOCIADOS A MARCAS
CREATE TABLE IF NOT EXISTS public.modelos (
    id_modelo bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_marca bigint NOT NULL,
    nombre character varying(50) NOT NULL,
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT modelos_id_marca_fkey
        FOREIGN KEY (id_marca) REFERENCES public.marcas(id_marca),
    CONSTRAINT modelos_unique_marca_nombre
        UNIQUE (id_marca, nombre)
);

-- VEHÍCULOS: VEHÍCULOS DE CLIENTES
CREATE TABLE IF NOT EXISTS public.vehiculos (
    id_vehiculo bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_cliente bigint NOT NULL,
    placa character varying(20) NOT NULL UNIQUE,
    id_marca bigint NOT NULL,
    id_modelo bigint,
    anio smallint,
    tipo_vehiculo character varying(20) NOT NULL,
    observaciones character varying(255),
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT vehiculos_id_cliente_fkey
        FOREIGN KEY (id_cliente) REFERENCES public.clientes(id_cliente),
    CONSTRAINT vehiculos_id_marca_fkey
        FOREIGN KEY (id_marca) REFERENCES public.marcas(id_marca),
    CONSTRAINT vehiculos_id_modelo_fkey
        FOREIGN KEY (id_modelo) REFERENCES public.modelos(id_modelo)
);

-- =============================================================================
-- COMPONENTES: PIEZAS TRAÍDAS SIN VEHÍCULO
-- =============================================================================
CREATE TABLE IF NOT EXISTS public.componentes (
    id_componente bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_cliente bigint NOT NULL,
    tipo_componente public.tipo_componente_enum NOT NULL,
    id_marca bigint NOT NULL,
    id_modelo bigint NOT NULL,
    cantidad integer NOT NULL DEFAULT 1,
    observaciones character varying(255),
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT componentes_id_cliente_fkey
        FOREIGN KEY (id_cliente) REFERENCES public.clientes (id_cliente),
    CONSTRAINT componentes_id_marca_fkey
        FOREIGN KEY (id_marca) REFERENCES public.marcas (id_marca),
    CONSTRAINT componentes_id_modelo_fkey
        FOREIGN KEY (id_modelo) REFERENCES public.modelos (id_modelo)
);

-- =============================================================================
-- SERVICIOS
-- =============================================================================

-- SERVICIOS: TRABAJOS OFRECIDOS EN EL TALLER
CREATE TABLE IF NOT EXISTS public.servicios (
    id_servicio bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    codigo character varying(20) NOT NULL UNIQUE,
    nombre character varying(120) NOT NULL,
    descripcion character varying(255),
    precio_base numeric(14,0) DEFAULT 0 NOT NULL,
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL
);

-- =============================================================================
-- ROLES / PERMISOS / ROLES_PERMISOS
-- =============================================================================

-- ROLES: CATÁLOGO DE ROLES DEL SISTEMA
CREATE TABLE IF NOT EXISTS public.roles (
    id_rol bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    codigo character varying(50) NOT NULL UNIQUE,
    nombre character varying(120) NOT NULL,
    descripcion character varying(255),
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL
);

-- PERMISOS: CATÁLOGO DE PERMISOS/ACCIONES DEL SISTEMA
CREATE TABLE IF NOT EXISTS public.permisos (
    id_permiso bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    codigo character varying(80) NOT NULL UNIQUE,
    nombre character varying(120) NOT NULL,
    descripcion character varying(255),
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL
);

-- ROLES_PERMISOS: PERMISOS ASOCIADOS A CADA ROL (N:M)
CREATE TABLE IF NOT EXISTS public.roles_permisos (
    id_rol bigint NOT NULL,
    id_permiso bigint NOT NULL,
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL,
    PRIMARY KEY (id_rol, id_permiso),
    CONSTRAINT roles_permisos_id_rol_fkey
        FOREIGN KEY (id_rol) REFERENCES public.roles(id_rol) ON DELETE CASCADE,
    CONSTRAINT roles_permisos_id_permiso_fkey
        FOREIGN KEY (id_permiso) REFERENCES public.permisos(id_permiso) ON DELETE CASCADE
);

-- =============================================================================
-- USUARIOS
-- =============================================================================

-- USUARIOS: EMPLEADOS O RESPONSABLES DE LAS OT
CREATE TABLE IF NOT EXISTS public.usuarios (
    id_usuario bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_rol bigint NOT NULL,
    nombre character varying(50) NOT NULL,
    apellido character varying(50) NOT NULL,
    nombre_usuario character varying(50) NOT NULL UNIQUE,
    email character varying(100) NOT NULL UNIQUE,
    password_hash character varying(255) NOT NULL,
    id_tipo_documento bigint NOT NULL,
    numero_documento character varying(40) NOT NULL,
    fecha_nacimiento date,
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT usuarios_id_tipo_documento_fkey
        FOREIGN KEY (id_tipo_documento) REFERENCES public.tipos_documento(id_tipo_documento),
    CONSTRAINT usuarios_id_rol_fkey
        FOREIGN KEY (id_rol) REFERENCES public.roles(id_rol)
);

-- =============================================================================
-- ORDENES_TRABAJO
-- REQUIERE ENUMS:
--   public.tipo_ingreso_orden_enum
--   public.estado_orden_trabajo_enum
-- =============================================================================

-- ORDENES_TRABAJO: CABECERA DE ORDENES
CREATE TABLE IF NOT EXISTS public.ordenes_trabajo (
    id_orden_trabajo bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    numero_orden character varying(30) NOT NULL UNIQUE, -- generado desde 03_post
    id_usuario bigint NOT NULL,
    id_cliente bigint NOT NULL,
    tipo_ingreso public.tipo_ingreso_orden_enum NOT NULL,
    id_vehiculo bigint,
    id_componente bigint,
    fecha_ingreso timestamp without time zone DEFAULT now() NOT NULL,
    problema_reportado character varying(255),
    observaciones_ingreso character varying(255),
    estado public.estado_orden_trabajo_enum NOT NULL,
    fecha_entrega timestamp without time zone,
    total_estimado numeric(14,0) DEFAULT 0 NOT NULL,
    fecha_fin timestamp without time zone,
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT ordenes_trabajo_id_usuario_fkey
        FOREIGN KEY (id_usuario) REFERENCES public.usuarios(id_usuario),
    CONSTRAINT ordenes_trabajo_id_cliente_fkey
        FOREIGN KEY (id_cliente) REFERENCES public.clientes(id_cliente),
    CONSTRAINT ordenes_trabajo_id_vehiculo_fkey
        FOREIGN KEY (id_vehiculo) REFERENCES public.vehiculos(id_vehiculo),
    CONSTRAINT ordenes_trabajo_id_componente_fkey
        FOREIGN KEY (id_componente) REFERENCES public.componentes(id_componente)
);

-- =============================================================================
-- DETALLES DE ORDEN
-- =============================================================================

-- ORDEN_TRABAJO_DETALLES: DETALLES DE SERVICIOS DE LA ORDEN
CREATE TABLE IF NOT EXISTS public.orden_trabajo_detalles (
    id_detalle bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_orden_trabajo bigint NOT NULL,
    id_servicio bigint NOT NULL,
    descripcion character varying(255),
    cantidad integer NOT NULL DEFAULT 1,
    precio_unitario numeric(14,0) DEFAULT 0 NOT NULL,
    subtotal numeric(14,0) GENERATED ALWAYS AS (cantidad * precio_unitario) STORED,
    observaciones character varying(255),
    garantia_meses smallint,
    garantia_dias smallint,
    garantia_desde date,
    garantia_hasta date,
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT orden_trabajo_detalles_id_orden_trabajo_fkey
        FOREIGN KEY (id_orden_trabajo) REFERENCES public.ordenes_trabajo(id_orden_trabajo),
    CONSTRAINT orden_trabajo_detalles_id_servicio_fkey
        FOREIGN KEY (id_servicio) REFERENCES public.servicios(id_servicio),
    -- impide precio unitario negativo
    CONSTRAINT orden_trabajo_detalles_precio_unitario_no_negativo
        CHECK (precio_unitario >= 0)
);

-- =============================================================================
-- PLANES DE PAGO
-- =============================================================================

-- PLANES_PAGO: PLANES DE PAGO ASOCIADOS A ORDENES
CREATE TABLE IF NOT EXISTS public.planes_pago (
    id_plan_pago bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_orden_trabajo bigint NOT NULL,
    tipo_plan public.tipo_plan_pago_enum NOT NULL,
    estado public.estado_plan_pago_enum NOT NULL,
    fecha_inicio date DEFAULT CURRENT_DATE,
    fecha_vencimiento date,
    monto_cuota numeric(14,0) DEFAULT 0 NOT NULL,
    dia_pago smallint,
    cantidad_cuotas smallint DEFAULT 1 NOT NULL,
    observaciones character varying(255),
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT planes_pago_id_orden_trabajo_fkey
        FOREIGN KEY (id_orden_trabajo) REFERENCES public.ordenes_trabajo(id_orden_trabajo)
);

-- =============================================================================
-- EVENTOS DE PLAN
-- =============================================================================

-- PLANES_PAGO_EVENTOS: HISTORIAL/SEGUIMIENTO DEL PLAN DE PAGO
CREATE TABLE IF NOT EXISTS public.planes_pago_eventos (
    id_evento bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_plan_pago bigint NOT NULL,
    fecha_evento timestamp without time zone DEFAULT now() NOT NULL,
    tipo_evento public.tipo_evento_plan_pago_enum NOT NULL,
    fecha_compromiso date,
    monto_compromiso numeric(14,0),
    detalle character varying(255),
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT planes_pago_eventos_id_plan_pago_fkey
        FOREIGN KEY (id_plan_pago) REFERENCES public.planes_pago(id_plan_pago)
);

-- =============================================================================
-- PAGOS
-- =============================================================================

-- PAGOS: REGISTRO DE PAGOS DE ORDENES/PLANES
CREATE TABLE IF NOT EXISTS public.pagos (
    id_pago bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_usuario bigint NOT NULL,
    id_orden_trabajo bigint NOT NULL,
    id_plan_pago bigint,
    fecha_pago timestamp without time zone DEFAULT now() NOT NULL,
    monto numeric(14,0) DEFAULT 0 NOT NULL,
    forma_pago public.forma_pago_enum NOT NULL,
    referencia character varying(80),
    observaciones character varying(255),
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT pagos_id_usuario_fkey
        FOREIGN KEY (id_usuario) REFERENCES public.usuarios(id_usuario),
    CONSTRAINT pagos_id_orden_trabajo_fkey
        FOREIGN KEY (id_orden_trabajo) REFERENCES public.ordenes_trabajo(id_orden_trabajo),
    CONSTRAINT pagos_id_plan_pago_fkey
        FOREIGN KEY (id_plan_pago) REFERENCES public.planes_pago(id_plan_pago)
);

-- =============================================================================
-- OWNER - PROPIETARIO DE OBJETOS
-- =============================================================================

-- GEOGRAFÍA
ALTER TABLE IF EXISTS public.paises OWNER TO postgres;
ALTER TABLE IF EXISTS public.departamentos OWNER TO postgres;
ALTER TABLE IF EXISTS public.distritos OWNER TO postgres;
ALTER TABLE IF EXISTS public.localidades OWNER TO postgres;

-- CLIENTES Y DOCUMENTOS
ALTER TABLE IF EXISTS public.clientes OWNER TO postgres;
ALTER TABLE IF EXISTS public.clientes_persona OWNER TO postgres;
ALTER TABLE IF EXISTS public.clientes_empresa OWNER TO postgres;
ALTER TABLE IF EXISTS public.tipos_documento OWNER TO postgres;
ALTER TABLE IF EXISTS public.cliente_documentos OWNER TO postgres;

-- ACTIVOS DEL TALLER (VEHÍCULOS Y COMPONENTES)
ALTER TABLE IF EXISTS public.marcas OWNER TO postgres;
ALTER TABLE IF EXISTS public.modelos OWNER TO postgres;
ALTER TABLE IF EXISTS public.vehiculos OWNER TO postgres;
ALTER TABLE IF EXISTS public.componentes OWNER TO postgres;
ALTER TABLE IF EXISTS public.servicios OWNER TO postgres;

-- USUARIOS Y OPERACIONES
ALTER TABLE IF EXISTS public.roles OWNER TO postgres;
ALTER TABLE IF EXISTS public.permisos OWNER TO postgres;
ALTER TABLE IF EXISTS public.roles_permisos OWNER TO postgres;
ALTER TABLE IF EXISTS public.usuarios OWNER TO postgres;
ALTER TABLE IF EXISTS public.ordenes_trabajo OWNER TO postgres;
ALTER TABLE IF EXISTS public.orden_trabajo_detalles OWNER TO postgres;

-- FINANZAS (PLANES Y PAGOS)
ALTER TABLE IF EXISTS public.planes_pago OWNER TO postgres;
ALTER TABLE IF EXISTS public.planes_pago_eventos OWNER TO postgres;
ALTER TABLE IF EXISTS public.pagos OWNER TO postgres;

-- =============================================================================
-- FIN DEL SCRIPT 01_SCHEMA
-- =============================================================================
