-- =============================================================================
-- 01 - SCHEMAS (ESTRUCTURA)
-- INCLUYE: CONFIGURACIÓN, TABLAS, IDENTITY, DEFAULTS, CONSTRAINTS (FK / CHECK),
--          ÍNDICES ESTRUCTURALES Y TRIGGERS DE INTEGRIDAD
-- =============================================================================

-- =============================================================================
-- CONFIGURACIÓN INICIAL
-- =============================================================================
SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

SET default_tablespace = '';
SET default_table_access_method = heap;

-- =============================================================================
-- GEOGRAFÍA
-- PAÍS -> DEPARTAMENTO -> DISTRITO -> LOCALIDAD
-- =============================================================================

-- PAISES: LISTA DE PAÍSES
CREATE TABLE IF NOT EXISTS public.paises (
    id_pais bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre character varying(100) NOT NULL UNIQUE,
    iso2 char(2) UNIQUE,
    iso3 char(3) UNIQUE,
    activo boolean DEFAULT true NOT NULL
);

-- DEPARTAMENTOS: AGRUPACIÓN TERRITORIAL DENTRO DE UN PAÍS
CREATE TABLE IF NOT EXISTS public.departamentos (
    id_departamento bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_pais bigint NOT NULL,
    nombre character varying(120) NOT NULL UNIQUE,
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT departamentos_id_pais_fkey
        FOREIGN KEY (id_pais) REFERENCES public.paises(id_pais)
);

-- DISTRITOS: DIVISIÓN TERRITORIAL DENTRO DE UN DEPARTAMENTO
CREATE TABLE IF NOT EXISTS public.distritos (
    id_distrito bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_departamento bigint NOT NULL,
    nombre character varying(120) NOT NULL,
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT distritos_id_departamento_fkey
        FOREIGN KEY (id_departamento) REFERENCES public.departamentos(id_departamento),
    CONSTRAINT distritos_unique_nombre_departamento
        UNIQUE (id_departamento, nombre)
);

-- LOCALIDADES: POBLADOS O CIUDADES DENTRO DE UN DISTRITO
CREATE TABLE IF NOT EXISTS public.localidades (
    id_localidad bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_distrito bigint NOT NULL,
    nombre character varying(120) NOT NULL,
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT localidades_id_distrito_fkey
        FOREIGN KEY (id_distrito) REFERENCES public.distritos(id_distrito),
    CONSTRAINT localidades_unique_nombre_distrito
        UNIQUE (id_distrito, nombre)
);

-- =============================================================================
-- CATÁLOGOS DEL TALLER
-- =============================================================================

-- MARCAS: CATÁLOGO DE MARCAS DE VEHÍCULOS O COMPONENTES
CREATE TABLE IF NOT EXISTS public.marcas (
    id_marca bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre character varying(50) NOT NULL UNIQUE,
    activo boolean DEFAULT true NOT NULL
);

-- MODELOS: CATÁLOGO DE MODELOS ASOCIADOS A MARCAS
CREATE TABLE IF NOT EXISTS public.modelos (
    id_modelo bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_marca bigint NOT NULL,
    nombre character varying(50) NOT NULL,
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT modelos_id_marca_fkey
        FOREIGN KEY (id_marca) REFERENCES public.marcas(id_marca),
    CONSTRAINT modelos_unique_marca_nombre
        UNIQUE (id_marca, nombre)
);

-- TIPOS_COMPONENTE: CATÁLOGO DE TIPOS DE COMPONENTES
CREATE TABLE IF NOT EXISTS public.tipos_componente (
    id_tipo_componente bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre character varying(50) NOT NULL UNIQUE,
    descripcion character varying(255),
    activo boolean DEFAULT true NOT NULL
);

-- VEHICULOS: CATÁLOGO DE VEHÍCULOS
CREATE TABLE IF NOT EXISTS public.vehiculos (
    id_vehiculo bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    placa character varying(20) UNIQUE,
    id_marca bigint NOT NULL,
    id_modelo bigint,
    anio smallint,
    tipo_vehiculo character varying(20) NOT NULL,
    observaciones character varying(255),
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT vehiculos_id_marca_fkey
        FOREIGN KEY (id_marca) REFERENCES public.marcas(id_marca),
    CONSTRAINT vehiculos_id_modelo_fkey
        FOREIGN KEY (id_modelo) REFERENCES public.modelos(id_modelo)
);

-- COMPONENTES: CATÁLOGO DE COMPONENTES
CREATE TABLE IF NOT EXISTS public.componentes (
    id_componente bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_tipo_componente bigint NOT NULL,
    id_marca bigint NOT NULL,
    id_modelo bigint NOT NULL,
    numero_serie character varying(50),
    observaciones character varying(255),
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT componentes_id_tipo_componente_fkey
        FOREIGN KEY (id_tipo_componente) REFERENCES public.tipos_componente(id_tipo_componente),
    CONSTRAINT componentes_id_marca_fkey
        FOREIGN KEY (id_marca) REFERENCES public.marcas(id_marca),
    CONSTRAINT componentes_id_modelo_fkey
        FOREIGN KEY (id_modelo) REFERENCES public.modelos(id_modelo)
);

-- SERVICIOS: CATÁLOGO DE SERVICIOS OFRECIDOS EN EL TALLER
CREATE TABLE IF NOT EXISTS public.servicios (
    id_servicio bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    codigo character varying(20) NOT NULL UNIQUE,
    nombre character varying(120) NOT NULL,
    descripcion character varying(255),
    precio_base numeric(14,0) DEFAULT 0 NOT NULL,
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT servicios_precio_base_no_negativo
        CHECK (precio_base >= 0)
);

-- =============================================================================
-- CATÁLOGOS DEL SISTEMA Y RELACIONES
-- =============================================================================

-- TIPOS_DOCUMENTO: CATÁLOGO DE TIPOS DE DOCUMENTOS (CI, RUC, PASAPORTE, ETC.)
CREATE TABLE IF NOT EXISTS public.tipos_documento (
    id_tipo_documento bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre character varying(80) NOT NULL UNIQUE,
    abreviatura character varying(10) NOT NULL UNIQUE,
    activo boolean DEFAULT true NOT NULL
);

-- ROLES: CATÁLOGO DE ROLES DE USUARIOS
CREATE TABLE IF NOT EXISTS public.roles (
    id_rol bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre character varying(50) NOT NULL UNIQUE,
    descripcion character varying(255),
    activo boolean DEFAULT true NOT NULL
);

-- PERMISOS: CATÁLOGO DE PERMISOS DE LOS USUARIOS
CREATE TABLE IF NOT EXISTS public.permisos (
    id_permiso bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre character varying(50) NOT NULL UNIQUE,
    descripcion character varying(255),
    activo boolean DEFAULT true NOT NULL
);

-- ROLES_PERMISOS: RELACIÓN ENTRE ROLES Y PERMISOS
CREATE TABLE IF NOT EXISTS public.roles_permisos (
    id_rol_permiso bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_rol bigint NOT NULL,
    id_permiso bigint NOT NULL,
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT roles_permisos_id_rol_fkey
        FOREIGN KEY (id_rol) REFERENCES public.roles(id_rol),
    CONSTRAINT roles_permisos_id_permiso_fkey
        FOREIGN KEY (id_permiso) REFERENCES public.permisos(id_permiso),
    CONSTRAINT roles_permisos_unique_rol_permiso
        UNIQUE (id_rol, id_permiso)
);

-- =============================================================================
-- USUARIO DEL SISTEMA
-- =============================================================================

CREATE TABLE IF NOT EXISTS public.usuarios (
    id_usuario bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username character varying(50) NOT NULL UNIQUE,
    password character varying(255) NOT NULL,
    nombre character varying(80) NOT NULL,
    apellido character varying(80) NOT NULL,
    id_tipo_documento bigint NOT NULL,
    numero_documento character varying(40) NOT NULL,
    email character varying(120),
    telefono character varying(20),
    id_rol bigint NOT NULL,
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT usuarios_id_tipo_documento_fkey
        FOREIGN KEY (id_tipo_documento) REFERENCES public.tipos_documento(id_tipo_documento),
    CONSTRAINT usuarios_id_rol_fkey
        FOREIGN KEY (id_rol) REFERENCES public.roles(id_rol)
);

-- =============================================================================
-- CLIENTES
-- =============================================================================

-- CLIENTES: TABLA BASE DE CLIENTES (PERSONA O EMPRESA)
CREATE TABLE IF NOT EXISTS public.clientes (
    id_cliente bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_distrito bigint,
    id_localidad bigint,
    -- referencia: vino por recomendación de otro cliente
    id_cliente_referidor bigint,
    fuente_referencia public.fuente_referencia_cliente_enum DEFAULT 'NINGUNA',
    telefono character varying(30),
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT clientes_id_distrito_fkey
        FOREIGN KEY (id_distrito) REFERENCES public.distritos(id_distrito),
    CONSTRAINT clientes_id_localidad_fkey
        FOREIGN KEY (id_localidad) REFERENCES public.localidades(id_localidad),
    CONSTRAINT clientes_id_cliente_referidor_fkey
        FOREIGN KEY (id_cliente_referidor)
        REFERENCES public.clientes (id_cliente)
        ON UPDATE CASCADE
        ON DELETE SET NULL,
    -- evita que un cliente se refiera a sí mismo
    CONSTRAINT clientes_referidor_no_self
        CHECK (id_cliente_referidor IS NULL OR id_cliente_referidor <> id_cliente),
    -- si hay fuente de referencia, debe existir cliente referidor (y viceversa)
    CONSTRAINT clientes_ref_fuente_y_referidor
        CHECK (
            (fuente_referencia IS NULL AND id_cliente_referidor IS NULL)
            OR
            (fuente_referencia IS NOT NULL AND id_cliente_referidor IS NOT NULL)
        )
);

-- CLIENTES_PERSONA: DATOS ESPECÍFICOS DE PERSONAS
CREATE TABLE IF NOT EXISTS public.clientes_persona (
    id_cliente bigint PRIMARY KEY,
    nombre character varying(120) NOT NULL,
    apellido character varying(120) NOT NULL,
    apodo character varying(30),
    CONSTRAINT clientes_persona_id_cliente_fkey
        FOREIGN KEY (id_cliente) REFERENCES public.clientes(id_cliente)
);

-- CLIENTES_EMPRESA: DATOS ESPECÍFICOS DE EMPRESAS
CREATE TABLE IF NOT EXISTS public.clientes_empresa (
    id_cliente bigint PRIMARY KEY,
    razon_social character varying(255) NOT NULL,
    nombre_fantasia character varying(50),
    CONSTRAINT clientes_empresa_id_cliente_fkey
        FOREIGN KEY (id_cliente) REFERENCES public.clientes(id_cliente)
);


-- TRIGGERS PARA EVITAR QUE UN CLIENTE SEA PERSONA Y EMPRESA A LA VEZ

CREATE OR REPLACE FUNCTION public.fn_clientes_evitar_doble_tipo()
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM public.clientes_persona WHERE id_cliente = NEW.id_cliente
    ) THEN
        RAISE EXCEPTION 'Este cliente ya está registrado como PERSONA';
    END IF;
    
    IF EXISTS (
        SELECT 1 FROM public.clientes_empresa WHERE id_cliente = NEW.id_cliente
    ) THEN
        RAISE EXCEPTION 'Este cliente ya está registrado como EMPRESA';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_clientes_persona_no_empresa
BEFORE INSERT OR UPDATE OF id_cliente ON public.clientes_persona
FOR EACH ROW
EXECUTE FUNCTION public.fn_clientes_evitar_doble_tipo();

CREATE TRIGGER trg_clientes_empresa_no_persona
BEFORE INSERT OR UPDATE OF id_cliente ON public.clientes_empresa
FOR EACH ROW
EXECUTE FUNCTION public.fn_clientes_evitar_doble_tipo();

-- CLIENTE_DOCUMENTOS: PUEDE TENER VARIOS, CON INDICADOR DE PRINCIPAL
CREATE TABLE IF NOT EXISTS public.cliente_documentos (
    id_cliente_documento bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_cliente bigint NOT NULL,
    id_tipo_documento bigint NOT NULL,
    numero character varying(40) NOT NULL,
    principal boolean DEFAULT false NOT NULL,
    activo boolean DEFAULT false NOT NULL,
    CONSTRAINT cliente_documentos_id_cliente_fkey
        FOREIGN KEY (id_cliente) REFERENCES public.clientes(id_cliente),
    CONSTRAINT cliente_documentos_id_tipo_documento_fkey
        FOREIGN KEY (id_tipo_documento) REFERENCES public.tipos_documento(id_tipo_documento)
);

-- índice único parcial: evita más de un documento principal activo por cliente
CREATE UNIQUE INDEX IF NOT EXISTS uq_cliente_documentos_principal
    ON public.cliente_documentos (id_cliente)
    WHERE principal = true AND activo = true;

-- =============================================================================
-- ORDENES DE TRABAJO - PUNTO DE UNIÓN CLIENTE + VEHÍCULO/COMPONENTE
-- =============================================================================

-- ORDENES_TRABAJO: CABECERA DE ÓRDENES - UNIÓN DE CLIENTE + VEHÍCULO/COMPONENTE
CREATE TABLE IF NOT EXISTS public.ordenes_trabajo (
    id_orden_trabajo bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    numero_orden character varying(30) NOT NULL UNIQUE,
    id_usuario bigint NOT NULL,
    id_cliente bigint NOT NULL,
    tipo_ingreso character varying(15) NOT NULL,
    id_vehiculo bigint,
    id_componente bigint,
    fecha_ingreso timestamp without time zone DEFAULT now() NOT NULL,
    problema_reportado character varying(255),
    observaciones_ingreso character varying(255),
    estado character varying(20) NOT NULL,
    fecha_entrega timestamp without time zone,
    -- CAMPOS FINANCIEROS
    total_trabajo numeric(14,0) DEFAULT 0 NOT NULL,
    total_pagado numeric(14,0) DEFAULT 0 NOT NULL,
    saldo_pendiente numeric(14,0) DEFAULT 0 NOT NULL,
    estado_pago character varying(15) DEFAULT 'PENDIENTE' NOT NULL,
    fecha_fin timestamp without time zone,
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT ordenes_trabajo_id_usuario_fkey
        FOREIGN KEY (id_usuario) REFERENCES public.usuarios(id_usuario),
    CONSTRAINT ordenes_trabajo_id_cliente_fkey
        FOREIGN KEY (id_cliente) REFERENCES public.clientes(id_cliente),
    CONSTRAINT ordenes_trabajo_id_vehiculo_fkey
        FOREIGN KEY (id_vehiculo) REFERENCES public.vehiculos(id_vehiculo),
    CONSTRAINT ordenes_trabajo_id_componente_fkey
        FOREIGN KEY (id_componente) REFERENCES public.componentes(id_componente),
    CONSTRAINT ordenes_trabajo_tipo_ingreso_check
        CHECK (tipo_ingreso IN ('VEHICULO', 'COMPONENTE')),
    CONSTRAINT ordenes_trabajo_estado_check
        CHECK (estado IN ('ABIERTA', 'EN_PROCESO', 'EN_ESPERA', 'FINALIZADA', 'ENTREGADA', 'CANCELADA')),
    CONSTRAINT ordenes_trabajo_estado_pago_check
        CHECK (estado_pago IN ('PENDIENTE', 'PARCIAL', 'PAGADO')),
    CONSTRAINT ordenes_trabajo_sujeto_por_tipo
        CHECK (
            (tipo_ingreso = 'VEHICULO' AND id_vehiculo IS NOT NULL AND id_componente IS NULL) OR
            (tipo_ingreso = 'COMPONENTE' AND id_componente IS NOT NULL AND id_vehiculo IS NULL)
        ),
    CONSTRAINT ordenes_trabajo_total_trabajo_no_negativo
        CHECK (total_trabajo >= 0),
    CONSTRAINT ordenes_trabajo_total_pagado_no_negativo
        CHECK (total_pagado >= 0),
    CONSTRAINT ordenes_trabajo_saldo_pendiente_coherente
        CHECK (saldo_pendiente = (total_trabajo - total_pagado))
);

-- ORDEN_TRABAJO_DETALLES: DETALLES DE SERVICIOS APLICADOS A LA ORDEN
CREATE TABLE IF NOT EXISTS public.orden_trabajo_detalles (
    id_detalle bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_orden_trabajo bigint NOT NULL,
    id_servicio bigint NOT NULL,
    cantidad numeric(10,2) DEFAULT 1 NOT NULL,
    precio_unitario numeric(14,0) DEFAULT 0 NOT NULL,
    subtotal numeric(14,0) DEFAULT 0 NOT NULL,
    garantia_meses smallint,
    garantia_dias smallint,
    observaciones character varying(255),
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT orden_trabajo_detalles_id_orden_trabajo_fkey
        FOREIGN KEY (id_orden_trabajo) REFERENCES public.ordenes_trabajo(id_orden_trabajo),
    CONSTRAINT orden_trabajo_detalles_id_servicio_fkey
        FOREIGN KEY (id_servicio) REFERENCES public.servicios(id_servicio),
    CONSTRAINT orden_trabajo_detalles_cantidad_minima
        CHECK (cantidad > 0),
    CONSTRAINT orden_trabajo_detalles_precio_unitario_no_negativo
        CHECK (precio_unitario >= 0),
    CONSTRAINT orden_trabajo_detalles_garantia_meses_no_negativo
        CHECK (garantia_meses IS NULL OR garantia_meses >= 0),
    CONSTRAINT orden_trabajo_detalles_garantia_dias_no_negativo
        CHECK (garantia_dias IS NULL OR garantia_dias >= 0)
);

-- =============================================================================
-- TRIGGERS PARA ACTUALIZAR AUTOMÁTICAMENTE LOS CAMPOS FINANCIEROS DE LA OT
-- =============================================================================

-- TRIGGER 1: Actualiza total_trabajo cuando se modifican los detalles
CREATE OR REPLACE FUNCTION public.fn_actualizar_total_trabajo()
RETURNS TRIGGER AS $$
DECLARE
    nuevo_total numeric(14,0);
BEGIN
    -- Calcula el total sumando los subtotales de los detalles activos
    SELECT COALESCE(SUM(subtotal), 0) INTO nuevo_total
    FROM public.orden_trabajo_detalles
    WHERE id_orden_trabajo = COALESCE(NEW.id_orden_trabajo, OLD.id_orden_trabajo)
      AND activo = true;
    
    -- Actualiza el total_trabajo y recalcula saldo_pendiente
    UPDATE public.ordenes_trabajo
    SET total_trabajo = nuevo_total,
        saldo_pendiente = nuevo_total - total_pagado
    WHERE id_orden_trabajo = COALESCE(NEW.id_orden_trabajo, OLD.id_orden_trabajo);
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_actualizar_total_trabajo_insert
AFTER INSERT ON public.orden_trabajo_detalles
FOR EACH ROW
EXECUTE FUNCTION public.fn_actualizar_total_trabajo();

CREATE TRIGGER trg_actualizar_total_trabajo_update
AFTER UPDATE ON public.orden_trabajo_detalles
FOR EACH ROW
WHEN (OLD.subtotal IS DISTINCT FROM NEW.subtotal OR OLD.activo IS DISTINCT FROM NEW.activo)
EXECUTE FUNCTION public.fn_actualizar_total_trabajo();

CREATE TRIGGER trg_actualizar_total_trabajo_delete
AFTER DELETE ON public.orden_trabajo_detalles
FOR EACH ROW
EXECUTE FUNCTION public.fn_actualizar_total_trabajo();

-- =============================================================================
-- PLANES DE PAGO
-- =============================================================================

-- PLANES_PAGO: PLANES DE FINANCIACIÓN ASOCIADOS A ÓRDENES DE TRABAJO
CREATE TABLE IF NOT EXISTS public.planes_pago (
    id_plan_pago bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_orden_trabajo bigint NOT NULL,
    estado character varying(20) NOT NULL,
    fecha_inicio date DEFAULT CURRENT_DATE NOT NULL,
    fecha_vencimiento date,
    monto_cuota numeric(14,0) DEFAULT 0 NOT NULL,
    dia_pago smallint,
    cantidad_cuotas smallint DEFAULT 1 NOT NULL,
    observaciones character varying(255),
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT planes_pago_id_orden_trabajo_fkey
        FOREIGN KEY (id_orden_trabajo) REFERENCES public.ordenes_trabajo(id_orden_trabajo),
    CONSTRAINT planes_pago_estado_check
        CHECK (estado IN ('ACTIVO', 'PAUSADO', 'FINALIZADO', 'CANCELADO'))
);

-- PLANES_PAGO_EVENTOS: EVENTOS DEL PLAN DE PAGO
CREATE TABLE IF NOT EXISTS public.planes_pago_eventos (
    id_evento bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_plan_pago bigint NOT NULL,
    fecha_evento timestamp without time zone DEFAULT now() NOT NULL,
    tipo_evento character varying(30) NOT NULL,
    fecha_compromiso date,
    monto_compromiso numeric(14,0),
    detalle character varying(255),
    activo boolean DEFAULT true NOT NULL,
    CONSTRAINT planes_pago_eventos_id_plan_pago_fkey
        FOREIGN KEY (id_plan_pago) REFERENCES public.planes_pago(id_plan_pago),
    CONSTRAINT planes_pago_eventos_tipo_evento_check
        CHECK (tipo_evento IN ('CREACION', 'COMPROMISO_PAGO', 'CAMBIO_ESTADO', 'MODIFICACION', 'CANCELACION'))
);

-- =============================================================================
-- PAGOS
-- =============================================================================

-- PAGOS: PAGOS REGISTRADOS EN EL SISTEMA
CREATE TABLE IF NOT EXISTS public.pagos (
    id_pago bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_usuario bigint NOT NULL,
    id_orden_trabajo bigint NOT NULL,
    id_plan_pago bigint,
    fecha_pago timestamp without time zone DEFAULT now() NOT NULL,
    monto numeric(14,0) DEFAULT 0 NOT NULL,
    forma_pago character varying(20) NOT NULL,
    referencia character varying(80),
    observaciones character varying(255),
    activo boolean DEFAULT true NOT NULL,
    fecha_creacion timestamp without time zone DEFAULT now() NOT NULL,
    CONSTRAINT pagos_id_usuario_fkey
        FOREIGN KEY (id_usuario) REFERENCES public.usuarios(id_usuario),
    CONSTRAINT pagos_id_orden_trabajo_fkey
        FOREIGN KEY (id_orden_trabajo) REFERENCES public.ordenes_trabajo(id_orden_trabajo),
    CONSTRAINT pagos_id_plan_pago_fkey
        FOREIGN KEY (id_plan_pago) REFERENCES public.planes_pago(id_plan_pago),
    CONSTRAINT pagos_forma_pago_check
        CHECK (forma_pago IN ('EFECTIVO', 'TRANSFERENCIA', 'CHEQUE', 'TARJETA', 'OTRO'))
);

-- =============================================================================
-- TRIGGER PARA ACTUALIZAR PAGOS EN ÓRDENES DE TRABAJO
-- =============================================================================

-- TRIGGER 2: Actualiza total_pagado y estado_pago cuando se registran pagos
CREATE OR REPLACE FUNCTION public.fn_actualizar_pagos_orden()
RETURNS TRIGGER AS $$
DECLARE
    nuevo_total_pagado numeric(14,0);
    total_orden numeric(14,0);
    nuevo_estado_pago character varying(15);
BEGIN
    -- Calcula el total pagado sumando todos los pagos activos
    SELECT COALESCE(SUM(monto), 0) INTO nuevo_total_pagado
    FROM public.pagos
    WHERE id_orden_trabajo = COALESCE(NEW.id_orden_trabajo, OLD.id_orden_trabajo)
      AND activo = true;
    
    -- Obtiene el total del trabajo
    SELECT total_trabajo INTO total_orden
    FROM public.ordenes_trabajo
    WHERE id_orden_trabajo = COALESCE(NEW.id_orden_trabajo, OLD.id_orden_trabajo);
    
    -- Determina el estado del pago
    IF nuevo_total_pagado = 0 THEN
        nuevo_estado_pago := 'PENDIENTE';
    ELSIF nuevo_total_pagado >= total_orden THEN
        nuevo_estado_pago := 'PAGADO';
    ELSE
        nuevo_estado_pago := 'PARCIAL';
    END IF;
    
    -- Actualiza los campos financieros de la orden
    UPDATE public.ordenes_trabajo
    SET total_pagado = nuevo_total_pagado,
        saldo_pendiente = total_orden - nuevo_total_pagado,
        estado_pago = nuevo_estado_pago
    WHERE id_orden_trabajo = COALESCE(NEW.id_orden_trabajo, OLD.id_orden_trabajo);
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_actualizar_pagos_orden_insert
AFTER INSERT ON public.pagos
FOR EACH ROW
EXECUTE FUNCTION public.fn_actualizar_pagos_orden();

CREATE TRIGGER trg_actualizar_pagos_orden_update
AFTER UPDATE ON public.pagos
FOR EACH ROW
WHEN (OLD.monto IS DISTINCT FROM NEW.monto OR OLD.activo IS DISTINCT FROM NEW.activo)
EXECUTE FUNCTION public.fn_actualizar_pagos_orden();

CREATE TRIGGER trg_actualizar_pagos_orden_delete
AFTER DELETE ON public.pagos
FOR EACH ROW
EXECUTE FUNCTION public.fn_actualizar_pagos_orden();

-- =============================================================================
-- OWNER - PROPIETARIO DE OBJETOS
-- =============================================================================

-- GEOGRAFÍA
ALTER TABLE IF EXISTS public.paises OWNER TO postgres;
ALTER TABLE IF EXISTS public.departamentos OWNER TO postgres;
ALTER TABLE IF EXISTS public.distritos OWNER TO postgres;
ALTER TABLE IF EXISTS public.localidades OWNER TO postgres;

-- CLIENTES Y DOCUMENTOS
ALTER TABLE IF EXISTS public.tipos_documento OWNER TO postgres;
ALTER TABLE IF EXISTS public.clientes OWNER TO postgres;
ALTER TABLE IF EXISTS public.clientes_persona OWNER TO postgres;
ALTER TABLE IF EXISTS public.clientes_empresa OWNER TO postgres;
ALTER TABLE IF EXISTS public.cliente_documentos OWNER TO postgres;

-- CATÁLOGOS DEL TALLER
ALTER TABLE IF EXISTS public.marcas OWNER TO postgres;
ALTER TABLE IF EXISTS public.modelos OWNER TO postgres;
ALTER TABLE IF EXISTS public.tipos_componente OWNER TO postgres;
ALTER TABLE IF EXISTS public.vehiculos OWNER TO postgres;
ALTER TABLE IF EXISTS public.componentes OWNER TO postgres;
ALTER TABLE IF EXISTS public.servicios OWNER TO postgres;

-- USUARIOS Y PERMISOS
ALTER TABLE IF EXISTS public.roles OWNER TO postgres;
ALTER TABLE IF EXISTS public.permisos OWNER TO postgres;
ALTER TABLE IF EXISTS public.roles_permisos OWNER TO postgres;
ALTER TABLE IF EXISTS public.usuarios OWNER TO postgres;

-- ÓRDENES DE TRABAJO
ALTER TABLE IF EXISTS public.ordenes_trabajo OWNER TO postgres;
ALTER TABLE IF EXISTS public.orden_trabajo_detalles OWNER TO postgres;

-- PLANES DE PAGO Y PAGOS
ALTER TABLE IF EXISTS public.planes_pago OWNER TO postgres;
ALTER TABLE IF EXISTS public.planes_pago_eventos OWNER TO postgres;
ALTER TABLE IF EXISTS public.pagos OWNER TO postgres;